Ch4. SOLID
# 유지보수성이 높은 코드


> [!NOTE] 실무적인 세 가지 맥락
> 1. **영향 범위**: 코드로 인한 영향 범위가 어떻게 되는가?
> 2. **의존성**: 소프트웨어의 의존성 관리가 제대로 이뤄지고 있는가?
> 3. **확장성**: 쉽게 확장 가능한가?

# SOLID
## 단일 책임 원칙 (SRP)

클래스에 너무 많은 책임이 할당되어서는 안 되며, 단 하나의 책임만 있어야 한다.
하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다.

### 액터란?
- 액터는 메시지를 전달하는 주체
- 어떤 클래스를 사용하게 될 액터가 한 명이라면 단일 책임 원칙을 지키고 있는 것이고, 여럿이면 위반하고 있는 것이다.
- 클래스를 변경할 이유는 유일한 액터의 요구사항이 변경될 때로 제한되어야 한다.

## 개방 폐쇄 원칙 (OCP)

확장에는 열려 있고 변경에는 닫혀 있어야 한다.
코드를 확장하고자 할 때 취할 수 있는 최고의 전략은 기존 코드를 아예 건드리지 않는 것이다.
코드를 추상화된 역할에 의존하게 만듦으로써 OCP 원칙을 달성할 수 있다.

## 리스코프 치환 원칙 (LSP)

기본 클래스의 계약을 파생 클래스가 제대로 치환할 수 있는지 확인하라.
	Rectangle과 Square 예시
파생 클래스가 기본 클래스의 모든 동작을 완전히 대체할 수 있어야 한다.

## 인터페이스 분리 원칙 (ISP)

자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다는 원칙
	어떤 클래스가 자신에게 필요하지 않은 인터페이스의 메서드를 구현하거나 의존하지 않아야 한다.
통합된 인터페이스는 구현체에 불필요한 구현을 강요할 수 있다 -> 범용성을 갖춘 하나의 인터페이스를 만들기보다 다수의 특화된 인터페이스를 만드는 편이 낫다

## 의존성 역전 원칙 (DIP)

1. 고수준 모듈은 추상화에 의존해야 한다.
2. 고수준 모듈이 저수준 모듈에 의존해서는 안 된다.
3. 저수준 모듈은 추상화를 구현해야 한다.

# 의존성

## 의존이란?

다른 객체나 함수를 사용하는 상태
사용하기만 해도 의존하는 것 -> 소프트웨어는 의존하는 객체들의 집합이라고 볼 수 있다.

## 의존성 주입

필요한 의존성을 외부에서 넣어주는 것
주입을 통해 구체적인 클래스(구현체)에 대해 의존하지 않아, 의존하는 클래스의 개수가 줄어든다.
의존성 주입은 의존성을 제거하는 기법이 아닌, 의존 형태를 바꿔 의존성을 약화시키는 기법이다.

## 의존성 역전

1. 상위 인터페이스(Chef) 생성
2. 기존의 두 클래스(Restaurant, HamburgerChef)가 인터페이스에 의존하도록 변경
	추상화를 이용한 간접 의존의 형태로 변경

추상화를 도입해서 의존을 당하던 객체가 의존을 하는 객체로 변경하는 것이 의존성 역전이다.
세부 사항에 의존하지 않고, 정책에 의존하도록 코드를 작성하라.

### 의존성 역전이 만드는 경계

두 화살표가 인터페이스를 향해 의존 관계를 밀어내고 있기 때문에 인터페이스를 중심으로 경계를 만들 수 있다.
해당 경계는 모듈의 경계로 사용할 수 있다.
하위 모듈은 상위 모듈에 의존하지만, 상위 모듈은 하위 모듈에 의존하지 않는다.
	상위 모듈을 그대로 재사용하고 하위 모듈을 교체해서 새로운 기능을 제공하도록 변경 가능 -> 상위 묘듈의 재사용성 ⬆️

## 의존성이 강조되는 이유

코드를 변경하거나 확장할 때 영향받는 범위를 최소화할 수 있어야 한다.

### 의존성 전이

한 컴포넌트가 변경되면, 관련된 다른 컴포넌트들에 연쇄적으로 영향을 준다.
의존성은 화살표의 역방향으로 전이된다.

### 순환 참조

의존성이 전이된다는 특징으로 인해, 순환 참조는 의존성 전이의 영향 범위를 확장시킨다.

---
Ch.05 순환 참조
# 순환 참조

두 개 이상의 객체나 컴포넌트가 서로를 참조함으로써 의존 관계에 사이클이 생기는 것

- [i] JPA의 양방향 매핑은 순환 참조이다.

# 순환 참조의 문제점

순환 참조가 발생한다는 것은 서로에게 강하게 의존한다는 의미 == 하나의 컴포넌트

## 무한 루프
순환 참조가 있다면, 시스템에 무한 루프가 발생할 수 있다.
무한 루프는 단순히 개발자의 실수로 만들어지는 것이 아님
	`Jackson` 라이브러리를 이용한 JSON 직렬화/역직렬화 과정에서도 발생 가능

## 시스템 복잡도
순환 참조는 시스템의 복잡도를 높인다.
순환 참조가 있으면 어떤 객체에 접근할 수 있는 경로가 너무 많아짐 -> 의존 관계가 복잡하게 얽힘
한 도메인 모델들에 단일 진입점을 만들어서 필요한 객체가 있을 때 단방향으로 접근하도록 만드는 것이 좋다

### GC와 메모리 누수
-  참조 횟수 계산 방식을 사용하는 GCㅇ서 순환 참조는 메모리 누수를 유발할 수 있다
	순환 참조 상황에서는 서로가 서로를 참조하고 있기 때문에 이들의 참조 횟수는 항상 0보다 크다 -> 삭제 대상으로 영원히 인식하지 못함
- JVM 환경에서 사용되는 기본 GC가 마크-앤드-스위프라는 더 개선된 알고리즘을 사용하여, 순환 참조 객체도 제거

# 순환 참조를 해결하는 방법

## 불필요한 참조 제거

즉, 양방향 참조가 꼭 필요한지 재고해 본다. 혹은 한쪽이 다른 한쪽의 식별자를 갖고 있게 해서 간접 참조 형태로 관계를 바꾸는 것

- [i] 한 방 쿼리 VS 단순한 쿼리
	간접 참조를 사용하면 시스템에 SQL 쿼리 몇 줄이 추가될 수 있다. 그러나 데이터베이스에서 간접 참조에 사용되는 식별자는 보통 기본키로 인덱싱되어 있고, 시스템 곳곳에 마련된 다양한 캐싱 장치가 쿼리 속도를 높여 준다.

## 공통 컴포넌트 분리

`A <-> B`에서 `A -> C, B -> C`와 같은 형태로 양쪽 서비스에 있던 공통 기능을 하나의 컴포넌트로 분리하는 방법
	공통 기능을 분리하는 과정에서 책임 분배가 적절하게 재조정된다는 장점이 있다
	기능적 응집도를 높인다

## 이벤트 기반 시스템 사용

1. 시스템에서 사용할 중앙 큐 생성
2. 필요에 따라 컴포넌트들이 중앙 큐를 구독하도록 함
3. 다른 컴포넌트에게 시켜야 할 일이 있다면 큐에 이벤트를 발행
4. 컴포넌트들은 자신이 처리해야 하는 이벤트라면 이를 읽어서 처리

이벤트 기반 시스템에서 서비스는 더 이상 서로를 상호 참조하지 않음

# 양방향 매핑

JPA는 수단일 뿐이며, 수단에 의해 시스템 설계가 영향을 받아서는 안 된다.

- [i] 다른 시각
	양방향 매핑은 SQL 쿼리를 만들기 쉽다. 도메인 객체와 도메인 영속성 객체를 분리한다면, 도메인 객체는 순환 참조를 만들지 않되 영속성 객체는 쿼리를 쉽게 만들기 위해 양방향 매핑을 사용할 수도 있다.

# 상위 수준의 순환 참조

패키지를 잘 구성한다면 모듈 시스템처럼 만들 수도 있으며, 잘 만들어진 패키지는 그 자체로 분리해서 새로운 서비스를 만들 수 있을 정도로 독립적이다. 
패키지나 시스템, 모듈 수준에서 순환 참조가 발생하면 분리와 유연성이 제한된다. 따라서 개발자는 클래스뿐만 아니라 이러한 상위 수준에서 발생하는 순환 참조를 방지하기 위해 주의해야 한다.
