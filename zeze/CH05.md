## 5.1 순환 참조의 문제점

### 5.1.1 무한 루프

객체 A가 객체 B의 메서드를 호출하고 객체 B가 객체 A의 또 어떤 메서드를 호출해서 무한 루프가 만들어진다.

무한 루프는 개발자가 메서드 호출 과정을 신경 쓴다고 해결할 수 있는 문제가 아니다. 소프트웨어는 복잡계라서 언제, 어디서, 어떤 식으로 부작용이 발생할 수 있을지 모른다. 그러므로 순환 참조로 인해 발생할 잠재적 위험을 안고 갈 이유가 없다.

### 5.1.2 시스템 복잡도

Team-Member 관계에서 '팀 내 모든 구성원의 월급을 합산해 주세요'라는 요구사항이 생겼다고 가정하자.

```java
@Data
class Team {
    ...
}

@Data
class Member {
    ...
    private Team myTeam;
    private int salary;

    public int calculateTeamMemberTotalSalary() {
        int result = 0;
        for (Member member ; myTeam.getMembers()) {
            result += member.salary;
        }
        return result;
    }
}
```

팀원이 팀 내 전체 구성원의 월급을 알 수 있는 시스템이라니 현실 세계에선 벌어질 수 없는 이상한 상황이다. 시스템의 잘못된 설계로 인해 이런 코드가 만들어질 수도 있다. 부적절한 구현 방법으로 인해 더 나은 구현 방법이 있는데도 개발자들이 자꾸 잘못된 방법으로 구현하게 만든다.

**해결책1. 양방향 참조 제거**

```java
@Data
class Team {
    ...
}

@Data
class Member {
    ...
    private long myTeamId;
    private int salary;
}
```

직접 참조에서 간접 참조로 바뀌었다. 이렇게 된다면 아까와같은 요구사항이 들어왔을 때 자연스럽게 Team 클래스의 메서드로 구현됐을 것이다.

**해결책2. 상위 객체에 있던 하위 객체에 대한 참조 제거**

```java
@Data
class Team {
    private long id;
    private String name;
    // Team이 갖고 있던 members 제거
}

@Data
class Member {
    ...
    private Team myTeam;
    private int salary;
}
```

이때는 Team 객체만으로 팀원의 월급을 모두 확인할 수 없으니 TeamService 컴포넌트에서 구현하면 된다.

### 기타: 메모리 누수

순환 참조 문제점을 찾다보면 빠지지 않고 나오는 이야기가 메모리 누수와 관련된 내용이다. 참조 횟수 게산 방식을 사용하는 GC에서 순환 참조는 메모리 누수를 발생할 수도 있다. 순환 참조에서는 서로가 서로를 참조하고 있기 때문에 참조 횟수가 항상 0보다 커서 GC가 이를 삭제 대상으로 인식하지 못하고 영원히 메모리 영역에 남게 한다.

하지만 GC는 실제로는 마크-앤드-스위프라는 더 개선된 알고리즘을 사용한다. 이는 객체 삭제 팓단 기준이 참조 횟수가 아니라 루트 객체로부터의 접근 가능성이다. 따라서 객체가 서로 순환 참조하더라도 그 객들이 루트 객체로부터 접근 가능하지 않다면 삭제 대상이 될 수 있다.

## 5.2 순환 참조를 해결하는 방법

### 5.2.3 공통 컴포넌트 분리

서비스 같은 컴포넌트에 순환 참조가 있고 그것이 각 컴포넌트의 설정상 필수적이라면 순환되는 코드만 분리해서 새로운 컴포넌트를 만들 수 있다.

이는 공통 기능을 분리하는 과정에서 책임 분배가 적절하게 재조정되게 한다. 컴포넌트의 기능적 분리는 결과적으로 과하게 부여됐던 책임을 분산하며 그 결과 기능적 응집도를 높이는 효과를 가져온다.

### 5.2.4 이벤트 기반 시스템 사용

공용 컴포넌트로도 분리할 수 없다면 이벤트 기반 프로그래밍을 시스템에 적용할 수 있다.

1. 시스템에서 사용할 중앙 큐를 만든다.
2. 필요에 따라 컴포넌트들이 중앙 큐를 구독하게 한다.
3. 컴포넌트들은 자신의 역할을 수행하던 중 다른 컴포넌트에 시켜야 할 일이 있다면 큐에 이벤트를 발행한다.
4. 이벤트가 발행되면 큐를 구독하고 있는 컴포넌트들이 반응한다.
5. 컴포넌트들은 이벤트를 확인하고 자신이 처리해야 하는 이벤트라면 이를 읽어 처리한다.
6. 컴포넌트들은 자신이 처리하지 않아도 되는 이벤트라면 무시한다.

스프링 프레임워크의 기능을 활용해서 구현하는 방법도 있고 카프카와 같은 메시지 시스템을 이용해 구현하는 방식도 있다. 이벤트 기반 시스템은 설계의 근간을 바꾸는 것이기 때문에 섣부르게 접근해서는 안 된다.

## 5.3 양방향 매핑

> 양방향 매핑이라는 개념이 순환 참조라는 죄악의 면죄부처럼 사용되고 있다.

> 양방향 매핑은 도메인 설계를 하다가 '어쩔 수 없이' 나오는 순환 참조 문제에 사용하는 것이 바람직하다.

### 양방향 매핑에 대한 다른 시각

하이버네이트에서는 양방향 매핑을 모범사레로 소개하기도 한다. 그 이유를 읽어보면 'SQL 쿼리를 만들기 쉽기 때문'이다. 양방향 매핑을 무조건 피하라는 것은 아니다. 도메인 객체와 영속성 객체를 분리한다면 도메인 객체는 순환 참조를 만들지 않되 영속성 객체는 쿼리를 쉽게 만들기 위해 양방향 매핑을 사용할 수도 있다. 하지만 대부분의 개발자는 JPA 엔티티를 도메인 객체로 사용하려는 경향이 있기 때문에 이때는 양방향 매핑이 JPA를 사용하는 모범 사례가 되기 어렵다.

## 5.4 상위 수준의 순환 참조

순환 참조는 객체뿐 아니라 패키지 사이나 시스템 수준에서도 발생할 수 있다. 이는 분리와 유연성을 제한시킨다. 따라서 개발자는 클래스뿐 아니라 상위 수준에서 발생하는 순환 참조를 방지하기 위해 주의해야 한다.